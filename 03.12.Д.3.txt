//Красно-чёрное дерево
#include <iostream>

using namespace std;

//узел дерева
struct Node {
    int key;
    int data;
    //цвет 
    // 0 - чёрный
    // 1 - красный
    bool color;
    Node* left;
    Node* right;
    Node* parent;

    Node() : key(NULL), color(0), parent(nullptr) {}
    Node(int k, int d) {
        key = k;
        data = d;
        color = 1;
        parent = nullptr;
    }
};

//дерево
struct RBTree {
    Node* nil = new Node();//нулевая вершина
    Node* root = nil;

    //вставка
    void add(int key, int data) {
        Node* node = new Node(key, data);
        node->left = nil;
        node->right = nil;
        root = add_node(root, node);
        root->color = 0;
    }
    Node* add_node(Node* node, Node* ptr) {
        if (node == nil)
            return ptr;

        if (ptr->key < node->key) {
            node->left = add_node(node->left, ptr);
            node->left->parent = node;
            node = fix(node);
        }
        else if (ptr->key > node->key) {
            node->right = add_node(node->right, ptr);
            node->right->parent = node;
            node = fix(node);
        }
        else {
            ptr->left = node->left;
            ptr->right = node->right;
            return ptr;
        }
        return node;
    }
    //проверка баланса
    Node* fix(Node* node) {
        if (node->left->color == 1 && node->right->color == 1 && node->right != nil && node->right->right->color == 1) {
            node->left->color = 0;
            node->right->color = 0;
            node->color = 1;
        }
        else if (node->right->color == 1 && node->left->color == 1 && node->left != nil && node->left->left->color == 1) {
            node->left->color = 0;
            node->right->color = 0;
            node->color = 1;
        }
        else if (node->left->color == 0 && node->right->color == 1 && node->right != nil && node->right->right->color == 1) {
            node->right->color = 0;
            node->color = 1;
            node = l_rotation(node);
        }
        else if (node->right->color == 0 && node->left->color == 1 && node->left != nil && node->left->left->color == 1) {
            node->left->color = 0;
            node->color = 1;
            node = r_rotation(node);
        }
        else if (node->right->color == 0 && node->left->color == 1 && node->left != nil && node->left->right->color == 1) {
            node->left->right->color = 0;
            node->color = 1;
            node->left = l_rotation(node->left);
            node = r_rotation(node);
        }
        
        else if (node->left->color == 0 && node->right->color == 1 && node->right->left->color == 1) {
            node->right->left->color = 0;
            node->color = 1;
            node->right = r_rotation(node->right);
            node = l_rotation(node);
        }
        else if (node->right->color == 1 && node->left->color == 1 && node->left != nil && node->left->right->color == 1) {
            node->color = 1;
            node->left->right->color = 0;
            node->right->color = 0;
            node->left = l_rotation(node->left);
        }
        else if (node->left->color == 1 && node->right->color == 1 && node->right != nil && node->right->left->color == 1) {
            node->color = 1;
            node->right->left->color = 0;
            node->left->color = 0;
            node->right = r_rotation(node->right);
        }
        return node;
    }
    //левое вращение
    Node* r_rotation(Node* ptr) {
        Node* node = ptr->left;
        ptr->left = node->right;
        node->right = ptr;
        return node;
    }
    //правое
    Node* l_rotation(Node* ptr) {
        Node* node = ptr->right;
        ptr->right = node->left;
        node->left = ptr;
        return node;
    }
    //удаление ключа
    Node* remove_key(Node*& root, int key) {
        if (root == nil) {
            return root;
        }
        if (key < root->key)
            root->left = remove_key(root->left, key);
        else if (key > root->key) {
            root->right = remove_key(root->right, key);
        }
        else if (root->left != nil && root->right != nil) {
            Node* node = minkey(root->right);
            root->key = node->key;
            root->data = node->data;
            remove_key(root->right, node->key);
        }
        else if (root->left == nil && root->right == nil) {
            root = nil;
        }
        else if (root->left == nil) {
            root = root->right;
            root->color = 0;
        }
        else if (root->right == nil) {
            root = root->left;
            root->color = 0;
        }

        if (root != nil && (black_h(root->left) != black_h(root->right))) {
            root = remove_fix(root);
        }
        return root;
    }
    void remove(int key) {
        remove_key(root, key);
    }
    Node* minkey(Node*& node) {
        Node* ptr = node;
        while (ptr->left != nil)
            ptr = ptr->left;
        return ptr;
    }
    Node* remove_fix(Node* node) {
        Node* left = node->left;
        Node* right = node->right;
        if (left != nil && left != nullptr) {
            if (left->left->color == 0 && left->right->color == 0 && left->color == 1 && right->color == 0) {
                left->color = 0;
                node->color = 1;
                node = r_rotation(node);
            }
            else if (left->left->color == 0 && left->right->color == 0 && left->color == 0 && right->color == 0) {
                left->color = 1;
                node->color = 0;
            }
            else if (left->right->color == 0 && left->right->color == 1 && left->color == 0 && right->color == 0) {
                left->color = 1;
                left->right->color = 0;
                left = l_rotation(left);
            }
            else if (left->left->color == 1 && left->color == 0 && right->color == 0) {
                left->color = node->color;
                node->color = 0;
                left->left->color = 0;
                node = r_rotation(node);
            }
        }
        else if (right != nil && right != nullptr) {
            //
            if (right->right->color == 0 && right->left->color == 0 && right->color == 1 && left->color == 0) {
                right->color = 0;
                node->color = 1;
                node = l_rotation(node);
            }
            else if (right->right->color == 0 && right->left->color == 0 && right->color == 0 && left->color == 0) {
                right->color = 1;
                node->color = 0;
            }
            else if (right->right->color == 0 && right->left->color == 1 && right->color == 0 && left->color == 0) {
                right->color = 1;
                right->left->color = 0;
                right = r_rotation(right);
            }
            else if (right->right->color == 1 && right->color == 0 && left->color == 0) {
                right->color = node->color;
                node->color = 0;
                right->right->color = 0;
                node = l_rotation(node);
            }
        }
        return node;
    }
    int max(int a, int b) {
        if (a > b) {
            return a;
        }
        return b;
    }
    int black_h(Node*& node) {
        if (node == nil) {
            return 0;
        }
        int height = 0;

        if (node->color == 0)
            height++;
        height += max(black_h(node->left), black_h(node->right));

        return height;
    }
    int size() {
        return find_size(root);
    }
    int find_size(Node* node) {
        int s = 0;
        if (node != nil) {
            s = 1;
            s += find_size(node->left);
            s += find_size(node->right);
        }
        return s;
    }
    void array_output() {
        array_print(root);
    }
    void array_print(Node* node) {
        if (node != nil) {
            array_print(node->left);
            cout << "[" << node->key << "; " << node->data << "] ";
            array_print(node->right);
        }
    }
    void output() {
        tree_output(root, 0);
    }
    void tree_output(Node* node, int s) {
        while (node != NULL) {
            if (node == nil) {
                for (int i = 0; i <= s; ++i) {
                    cout << " ";
                }
                cout << "NULL" << endl;
                return;
            }

            tree_output(node->right, s + 5);
            for (int i = 0; i <= s; ++i) {
                cout << " ";
            }
            if (node->color == 0) {
                cout << node->key << " " << "B" << endl;
            }
            else {
                cout << node->key << " " << "R" << endl;
            }
            node = node->left;
            s += 5;
        }

    }
    int get_data(int key) {
        Node* a = search(root, key);
        if (a == nullptr) {
            return NULL;
        }
        else {
            return a->data;
        }
    }
    Node* search(Node* node, int key) {
        if (node != nil) {
            if (key == node->key) {
                return node;
            }
            else if (key < node->key) {
                return search(node->left, key);
            }
            else {
                return search(node->right, key);
            }
        }
        else {
            return NULL;
        }
    }
    //удаление дерева
    void del() {
        delete_tree(root);
    }
    void delete_tree(Node* root) {
        if (root != nil) {
            delete_tree(root->left);
            delete_tree(root->right);
            delete root;
        }
    }
};

int main() {
    RBTree tree;
    int a;
    int b;
    while (cin >> a, cin>>b, a != 0) {
        tree.add(a, b);
    }


    tree.add(1, 0); 
    tree.add(2, 11); 
    tree.add(3, 45); 
    tree.add(943, 45); 
    tree.add(958, 34); 
    tree.add(457, 55); 
    tree.add(677, 34); 
    tree.add(836, 54); 
    tree.add(493, 37); 
    tree.add(945, 12); 
    tree.add(256, 210); 
    tree.add(157, 11);
    tree.add(567, 45);
    tree.add(832, 45);
    tree.add(146, 34);
    tree.add(267, 55);
    tree.add(825, 34);
    tree.add(385, 54);
    tree.add(945, 37);
    tree.add(215, 12);
    tree.output(); 
    cout << endl;
    cout << endl;
    tree.remove(215); 
    tree.output(); 
    cout << endl;
    cout<<endl; 
    cout << "value is :" << tree.get_data(256) << endl;

    tree.array_output();
    cout << endl;
    cout << "array size is: " << tree.size() << endl;
    cout << endl;
    tree.del();
}